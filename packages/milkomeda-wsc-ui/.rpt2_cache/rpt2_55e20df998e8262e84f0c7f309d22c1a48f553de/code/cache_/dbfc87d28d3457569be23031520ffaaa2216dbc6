{"code":"import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\nimport { useEffect, useState } from \"react\";\r\nimport { AnimatePresence } from \"framer-motion\";\r\nimport { Container, ConnectingContainer, ConnectingAnimation, RetryButton, RetryIconContainer, Content, } from \"./styles\";\r\nimport supportedConnectors from \"../../../constants/supportedConnectors\";\r\nimport { PageContent, ModalHeading, ModalBody, ModalH1, ModalContentContainer, ModalContent, } from \"../../Common/Modal/styles\";\r\nimport Button from \"../../Common/Button\";\r\nimport Tooltip from \"../../Common/Tooltip\";\r\nimport Alert from \"../../Common/Alert\";\r\nimport CircleSpinner from \"./CircleSpinner\";\r\nimport { RetryIconCircle } from \"../../../assets/icons\";\r\nimport BrowserIcon from \"../../Common/BrowserIcon\";\r\nimport { AlertIcon, TickIcon } from \"../../../assets/icons\";\r\nimport { detectBrowser } from \"../../../utils\";\r\nimport { useConnect } from \"../../../hooks/useConnect\";\r\nexport const states = {\r\n    CONNECTED: \"connected\",\r\n    CONNECTING: \"connecting\",\r\n    EXPIRING: \"expiring\",\r\n    FAILED: \"failed\",\r\n    REJECTED: \"rejected\",\r\n    NOTCONNECTED: \"notconnected\",\r\n    UNAVAILABLE: \"unavailable\",\r\n};\r\nconst contentVariants = {\r\n    initial: {\r\n        willChange: \"transform,opacity\",\r\n        position: \"relative\",\r\n        opacity: 0,\r\n        scale: 0.95,\r\n    },\r\n    animate: {\r\n        position: \"relative\",\r\n        opacity: 1,\r\n        scale: 1,\r\n        transition: {\r\n            ease: [0.16, 1, 0.3, 1],\r\n            duration: 0.4,\r\n            delay: 0.05,\r\n            position: { delay: 0 },\r\n        },\r\n    },\r\n    exit: {\r\n        position: \"absolute\",\r\n        opacity: 0,\r\n        scale: 0.95,\r\n        transition: {\r\n            ease: [0.16, 1, 0.3, 1],\r\n            duration: 0.3,\r\n        },\r\n    },\r\n};\r\nconst ConnectWithInjector = ({ connectorId, switchConnectMethod, forceState }) => {\r\n    var _a, _b;\r\n    const { connect, connectors } = useConnect({\r\n        onMutate: (connector) => {\r\n            if (connector.connector) {\r\n                setStatus(states.CONNECTING);\r\n            }\r\n            else {\r\n                setStatus(states.UNAVAILABLE);\r\n            }\r\n        },\r\n        onError(err) {\r\n            console.error(err);\r\n        },\r\n        onSettled(data, error) {\r\n            if (error) {\r\n                setShowTryAgainTooltip(true);\r\n                setTimeout(() => setShowTryAgainTooltip(false), 3500);\r\n                if (error.code) {\r\n                    // https://github.com/MetaMask/eth-rpc-errors/blob/main/src/error-constants.ts\r\n                    switch (error.code) {\r\n                        case -32002:\r\n                            setStatus(states.NOTCONNECTED);\r\n                            break;\r\n                        case 4001:\r\n                            setStatus(states.REJECTED);\r\n                            break;\r\n                        default:\r\n                            setStatus(states.FAILED);\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    // Sometimes the error doesn't respond with a code\r\n                    if (error.message) {\r\n                        switch (error.message) {\r\n                            case \"User rejected request\":\r\n                                setStatus(states.REJECTED);\r\n                                break;\r\n                            default:\r\n                                setStatus(states.FAILED);\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (data) {\r\n                /* empty */\r\n            }\r\n        },\r\n    });\r\n    const [id, setId] = useState(connectorId);\r\n    const [showTryAgainTooltip, setShowTryAgainTooltip] = useState(false);\r\n    const connector = supportedConnectors.filter((c) => c.id === id)[0];\r\n    const expiryDefault = 9; // Starting at 10 causes layout shifting, better to start at 9\r\n    const [expiryTimer, setExpiryTimer] = useState(expiryDefault);\r\n    const hasExtensionInstalled = connector.extensionIsInstalled && connector.extensionIsInstalled();\r\n    const browser = detectBrowser();\r\n    const extensionUrl = connector.extensions ? connector.extensions[browser] : undefined;\r\n    const suggestedExtension = connector.extensions\r\n        ? {\r\n            name: Object.keys(connector.extensions)[0],\r\n            label: Object.keys(connector.extensions)[0].charAt(0).toUpperCase() +\r\n                Object.keys(connector.extensions)[0].slice(1),\r\n            url: connector.extensions[Object.keys(connector.extensions)[0]],\r\n        }\r\n        : undefined;\r\n    const [status, setStatus] = useState(forceState ? forceState : !hasExtensionInstalled ? states.UNAVAILABLE : states.CONNECTING);\r\n    const runConnect = () => {\r\n        if (!hasExtensionInstalled)\r\n            return;\r\n        const con = connectors.find((c) => c.id === id);\r\n        if (con) {\r\n            connect({ connector: con });\r\n        }\r\n        else {\r\n            setStatus(states.UNAVAILABLE);\r\n        }\r\n    };\r\n    let connectTimeout;\r\n    useEffect(() => {\r\n        if (status === states.UNAVAILABLE)\r\n            return;\r\n        // UX: Give user time to see the UI before opening the extension\r\n        connectTimeout = setTimeout(runConnect, 600);\r\n        return () => {\r\n            clearTimeout(connectTimeout);\r\n        };\r\n    }, []);\r\n    /** Timeout functionality if necessary\r\n    let expiryTimeout: any;\r\n    useEffect(() => {\r\n      if (status === states.EXPIRING) {\r\n        expiryTimeout = setTimeout(\r\n          () => {\r\n            if (expiryTimer <= 0) {\r\n              setStatus(states.FAILED);\r\n              setExpiryTimer(expiryDefault);\r\n            } else {\r\n              setExpiryTimer(expiryTimer - 1);\r\n            }\r\n          },\r\n          expiryTimer === 9 ? 1500 : 1000 // Google: Chronostasis\r\n        );\r\n      }\r\n      return () => {\r\n        clearTimeout(expiryTimeout);\r\n      };\r\n    }, [status, expiryTimer]);\r\n    */\r\n    if (!connector) {\r\n        return (_jsx(PageContent, { children: _jsxs(Container, { children: [_jsx(ModalHeading, { children: \"Invalid State\" }), _jsx(ModalContent, { children: _jsx(Alert, { children: \"No connectors match the id given. This state should never happen.\" }) })] }) }));\r\n    }\r\n    return (_jsx(PageContent, { children: _jsxs(Container, { children: [_jsx(ConnectingContainer, { children: _jsxs(ConnectingAnimation, { \"$shake\": status === states.FAILED || status === states.REJECTED, \"$circle\": true, children: [_jsx(AnimatePresence, { children: (status === states.FAILED || status === states.REJECTED) && (_jsx(RetryButton, { \"aria-label\": \"Retry\", initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, whileTap: { scale: 0.9 }, transition: { duration: 0.1 }, onClick: runConnect, children: _jsx(RetryIconContainer, { children: _jsx(Tooltip, { open: showTryAgainTooltip &&\r\n                                                (status === states.FAILED || status === states.REJECTED), message: \"try again\", xOffset: -6, children: _jsx(RetryIconCircle, {}) }) }) })) }), _jsx(CircleSpinner, { logo: status === states.UNAVAILABLE ? (_jsx(\"div\", { style: {\r\n                                        transform: \"scale(1.14)\",\r\n                                        position: \"relative\",\r\n                                        width: \"100%\",\r\n                                    }, children: (_a = connector.logos.transparent) !== null && _a !== void 0 ? _a : connector.logos.default })) : (_jsx(_Fragment, { children: (_b = connector.logos.transparent) !== null && _b !== void 0 ? _b : connector.logos.default })), smallLogo: connector.id === \"injected\", connecting: status === states.CONNECTING, unavailable: status === states.UNAVAILABLE, countdown: status === states.EXPIRING })] }) }), _jsx(ModalContentContainer, { children: _jsxs(AnimatePresence, { initial: false, children: [status === states.FAILED && (_jsx(Content, { initial: \"initial\", animate: \"animate\", exit: \"exit\", variants: contentVariants, children: _jsxs(ModalContent, { children: [_jsxs(ModalH1, { \"$error\": true, children: [_jsx(AlertIcon, {}), \"Connection Failed\"] }), _jsx(ModalBody, { children: \"Sorry, something went wrong. Please try connecting again.\" })] }) }, states.FAILED)), status === states.REJECTED && (_jsx(Content, { initial: \"initial\", animate: \"animate\", exit: \"exit\", variants: contentVariants, children: _jsxs(ModalContent, { style: { paddingBottom: 28 }, children: [_jsx(ModalH1, { children: \"Rejected\" }), _jsx(ModalBody, { children: \"rejected description\" })] }) }, states.REJECTED)), (status === states.CONNECTING || status === states.EXPIRING) && (_jsx(Content, { initial: \"initial\", animate: \"animate\", exit: \"exit\", variants: contentVariants, children: _jsxs(ModalContent, { style: { paddingBottom: 28 }, children: [_jsx(ModalH1, { children: \"Requesting Connection\" }), _jsxs(ModalBody, { children: [\"Open the \", connector.name, \" browser extension to connect your wallet.\"] })] }) }, states.CONNECTING)), status === states.CONNECTED && (_jsx(Content, { initial: \"initial\", animate: \"animate\", exit: \"exit\", variants: contentVariants, children: _jsxs(ModalContent, { children: [_jsxs(ModalH1, { \"$valid\": true, children: [_jsx(TickIcon, {}), \" aaab\"] }), _jsx(ModalBody, { children: \"description\" })] }) }, states.CONNECTED)), status === states.NOTCONNECTED && (_jsx(Content, { initial: \"initial\", animate: \"animate\", exit: \"exit\", variants: contentVariants, children: _jsxs(ModalContent, { children: [_jsx(ModalH1, { children: \"not connected\" }), _jsx(ModalBody, { children: \"not connected description\" })] }) }, states.NOTCONNECTED)), status === states.UNAVAILABLE && (_jsx(Content, { initial: \"initial\", animate: \"animate\", exit: \"exit\", variants: contentVariants, children: !extensionUrl ? (_jsxs(_Fragment, { children: [_jsxs(ModalContent, { style: { paddingBottom: 12 }, children: [_jsx(ModalH1, { children: \"injectionScreen_unavailable_h1\" }), _jsx(ModalBody, { children: \"injectionScreen_unavailable_p\" })] }), !hasExtensionInstalled && suggestedExtension && (_jsxs(Button, { href: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.url, icon: _jsx(BrowserIcon, { browser: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.name }), children: [\"Install on \", suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label] }))] })) : (_jsxs(_Fragment, { children: [_jsxs(ModalContent, { style: { paddingBottom: 18 }, children: [_jsx(ModalH1, { children: \"injectionScreen_install_h1\" }), _jsx(ModalBody, { children: \"injectionScreen_install_p\" })] }), !hasExtensionInstalled && extensionUrl && (_jsx(Button, { href: extensionUrl, icon: _jsx(BrowserIcon, {}), children: \"Install extension\" }))] })) }, states.UNAVAILABLE))] }) })] }) }));\r\n};\r\nexport default ConnectWithInjector;\r\n","references":["/Users/paulclindo/local/dcspark/wrapped-smartcontracts/node_modules/@types/react/ts5.0/index.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/node_modules/framer-motion/dist/index.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/ConnectModal/ConnectWithInjector/styles.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/constants/supportedConnectors.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Modal/styles.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Modal/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Button/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Tooltip/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Alert/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/ConnectModal/ConnectWithInjector/CircleSpinner/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/assets/icons.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/BrowserIcon/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/assets/icons.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/utils/index.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/hooks/useConnect.tsx"],"dts":{"name":"/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/build/components/ConnectModal/ConnectWithInjector/index.d.ts","writeByteOrderMark":false,"text":"import React from \"react\";\r\nexport declare const states: {\r\n    CONNECTED: string;\r\n    CONNECTING: string;\r\n    EXPIRING: string;\r\n    FAILED: string;\r\n    REJECTED: string;\r\n    NOTCONNECTED: string;\r\n    UNAVAILABLE: string;\r\n};\r\ndeclare const ConnectWithInjector: React.FC<{\r\n    connectorId: string;\r\n    switchConnectMethod: (id?: string) => void;\r\n    forceState?: typeof states;\r\n}>;\r\nexport default ConnectWithInjector;\r\n"}}
