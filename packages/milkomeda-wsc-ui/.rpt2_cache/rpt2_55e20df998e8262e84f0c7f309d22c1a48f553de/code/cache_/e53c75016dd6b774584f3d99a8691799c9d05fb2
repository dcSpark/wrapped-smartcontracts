{"code":"import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from \"react/jsx-runtime\";\r\nimport { useContext } from \"../ConnectWSC\";\r\nimport React from \"react\";\r\nimport { convertWeiToTokens } from \"../../utils/convertWeiToTokens\";\r\nimport { AnimatePresence } from \"framer-motion\";\r\nimport { Balance, BalanceContainer, LoadingBalance } from \"../Pages/Profile/styles\";\r\nimport BigNumber from \"bignumber.js\";\r\nimport { BalancesWrapper, ErrorMessage, LabelText, LabelWithBalanceContainer, SpinnerWrapper, StepDescription, StepTitle, SuccessWrapper, WrapperButtons, } from \"./styles\";\r\nimport Button from \"../Common/Button\";\r\nimport { TxPendingStatus } from \"milkomeda-wsc\";\r\nimport { Spinner } from \"../Common/Spinner\";\r\nimport useInterval from \"../../hooks/useInterval\";\r\nimport { CheckCircle2 } from \"lucide-react\";\r\nimport { DEFAULT_STEP_TIMEOUT } from \"./constants\";\r\nexport const WrapStatus = {\r\n    ...TxPendingStatus,\r\n    Idle: \"Idle\",\r\n    Init: \"Init\",\r\n    Pending: \"Pending\",\r\n    Error: \"Error\",\r\n};\r\nconst statusWrapMessages = {\r\n    [WrapStatus.Init]: \"Confirm Wrapping\",\r\n    [WrapStatus.Pending]: \"Wrapping your token\",\r\n    [WrapStatus.WaitingL1Confirmation]: \"Waiting for L1 confirmation\",\r\n    [WrapStatus.WaitingBridgeConfirmation]: \"Waiting for bridge confirmation\",\r\n    [WrapStatus.WaitingL2Confirmation]: \"Waiting for L2 confirmation\",\r\n    [WrapStatus.Confirmed]: \"Your asset has been successfully wrapped!\",\r\n};\r\nconst WrapStep = ({ nextStep }) => {\r\n    const { setOpen, defaultCardanoAsset } = useContext();\r\n    const [selectedWrapToken, setSelectedWrapToken] = React.useState(null);\r\n    const { wscProvider, originTokens, stargateInfo } = useContext();\r\n    const [txHash, setTxHash] = React.useState(null);\r\n    const [txStatus, setTxStatus] = React.useState(WrapStatus.Idle);\r\n    const [txStatusError, setTxStatusError] = React.useState(null);\r\n    const isIdle = txStatus === WrapStatus.Idle;\r\n    const isLoading = txStatus === WrapStatus.Init ||\r\n        txStatus === WrapStatus.Pending ||\r\n        txStatus === WrapStatus.WaitingL1Confirmation ||\r\n        txStatus === WrapStatus.WaitingBridgeConfirmation ||\r\n        txStatus === WrapStatus.WaitingL2Confirmation;\r\n    const isError = txStatus === WrapStatus.Error;\r\n    const isSuccess = txStatus === WrapStatus.Confirmed;\r\n    useInterval(async () => {\r\n        if (!wscProvider || txHash == null)\r\n            return;\r\n        const response = await wscProvider.getTxStatus(txHash);\r\n        setTxStatus(response);\r\n        if (response === TxPendingStatus.Confirmed) {\r\n            setTxHash(null);\r\n            setTimeout(() => {\r\n                nextStep();\r\n            }, DEFAULT_STEP_TIMEOUT);\r\n        }\r\n    }, txHash != null ? 4000 : null);\r\n    const wrapToken = async () => {\r\n        if (!selectedWrapToken || !defaultCardanoAsset)\r\n            return;\r\n        setTxStatus(WrapStatus.Init);\r\n        try {\r\n            const txHash = await (wscProvider === null || wscProvider === void 0 ? void 0 : wscProvider.wrap(undefined, selectedWrapToken.unit, defaultCardanoAsset.amount));\r\n            setTxHash(txHash);\r\n            setTxStatus(WrapStatus.Pending);\r\n        }\r\n        catch (err) {\r\n            setTxStatus(WrapStatus.Error);\r\n            if (err instanceof Error) {\r\n                setTxStatusError(err.message);\r\n            }\r\n        }\r\n    };\r\n    React.useEffect(() => {\r\n        if (!defaultCardanoAsset)\r\n            return;\r\n        const loadOriginToken = async () => {\r\n            const token = originTokens.find((t) => t.unit === defaultCardanoAsset.unit);\r\n            if (!token)\r\n                return;\r\n            const defaultToken = {\r\n                ...token,\r\n                quantity: convertWeiToTokens({ valueWei: token.quantity, token }),\r\n            };\r\n            setSelectedWrapToken(defaultToken);\r\n        };\r\n        loadOriginToken();\r\n    }, [defaultCardanoAsset === null || defaultCardanoAsset === void 0 ? void 0 : defaultCardanoAsset.amount, defaultCardanoAsset === null || defaultCardanoAsset === void 0 ? void 0 : defaultCardanoAsset.unit, originTokens, setSelectedWrapToken]);\r\n    const fee = stargateInfo != null ? new BigNumber(stargateInfo === null || stargateInfo === void 0 ? void 0 : stargateInfo.stargateMinNativeTokenFromL1) : null;\r\n    const isAmountValid = selectedWrapToken != null && defaultCardanoAsset != null && fee != null\r\n        ? new BigNumber(defaultCardanoAsset.amount).plus(fee).lte(selectedWrapToken === null || selectedWrapToken === void 0 ? void 0 : selectedWrapToken.quantity)\r\n        : false;\r\n    return (_jsxs(\"div\", { children: [_jsx(StepTitle, { children: \"Wrap Tokens\" }), _jsx(StepDescription, { children: \"Explore the power of wrap tokens as they seamlessly connect Cardano and Ethereum, enabling users to leverage the benefits of both blockchain ecosystems. With wrap tokens, Cardano tokens can be wrapped and utilized on the Ethereum network.\" }), _jsxs(BalancesWrapper, { children: [_jsx(LabelWithBalance, { label: \"You're moving:\", amount: defaultCardanoAsset != null && new BigNumber(defaultCardanoAsset.amount).toFixed(), assetName: selectedWrapToken === null || selectedWrapToken === void 0 ? void 0 : selectedWrapToken.assetName }), _jsx(LabelWithBalance, { label: \"Wrapping fee:\", amount: fee === null || fee === void 0 ? void 0 : fee.toFixed(), assetName: selectedWrapToken === null || selectedWrapToken === void 0 ? void 0 : selectedWrapToken.assetName }), _jsx(LabelWithBalance, { label: \"You'll transfer:\", amount: fee &&\r\n                            defaultCardanoAsset != null &&\r\n                            new BigNumber(defaultCardanoAsset.amount).plus(fee).toFixed(), assetName: selectedWrapToken === null || selectedWrapToken === void 0 ? void 0 : selectedWrapToken.assetName })] }), isLoading && (_jsxs(_Fragment, { children: [_jsxs(SpinnerWrapper, { children: [_jsx(Spinner, {}), _jsx(\"span\", { children: statusWrapMessages[txStatus] })] }), _jsx(\"p\", { children: \"Wrapping transaction may take a few minutes (~3m).\" })] })), isSuccess && (_jsxs(SuccessWrapper, { children: [_jsx(CheckCircle2, {}), _jsx(\"span\", { children: statusWrapMessages[TxPendingStatus.Confirmed] })] })), selectedWrapToken != null && !selectedWrapToken.bridgeAllowed && (_jsx(ErrorMessage, { role: \"alert\", children: \"Error: Bridge doesn't allow this token\" })), selectedWrapToken != null && !isAmountValid && (_jsx(ErrorMessage, { role: \"alert\", children: \"Error: Amount exceeds your current balance\" })), isError && (_jsxs(ErrorMessage, { role: \"alert\", children: [\"Ups, something went wrong. \", txStatusError ? `Error: ${txStatusError}` : \"\", \" \"] })), (isIdle || isError) && (_jsxs(WrapperButtons, { children: [_jsx(Button, { onClick: () => setOpen(false), children: \"Cancel\" }), _jsx(Button, { variant: \"primary\", onClick: wrapToken, children: \"Confirm wrapping\" })] }))] }));\r\n};\r\nexport default WrapStep;\r\nexport const LabelWithBalance = ({ label, amount, assetName }) => {\r\n    return (_jsxs(LabelWithBalanceContainer, { children: [_jsxs(LabelText, { children: [label, \" \"] }), _jsx(BalanceContainer, { children: _jsx(AnimatePresence, { exitBeforeEnter: true, initial: false, children: amount && assetName ? (_jsx(Balance, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, children: _jsxs(\"span\", { children: [amount, ` `, assetName] }) })) : (_jsx(LoadingBalance, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, children: \"\\u00A0\" })) }) })] }));\r\n};\r\n","references":["/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/ConnectWSC.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/node_modules/@types/react/ts5.0/index.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/utils/convertWeiToTokens.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/node_modules/framer-motion/dist/index.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Pages/Profile/styles.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/node_modules/bignumber.js/bignumber.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/TransactionStepper/styles.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Button/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/node_modules/milkomeda-wsc/build/index.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/Common/Spinner/index.tsx","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/hooks/useInterval.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/node_modules/lucide-react/dist/lucide-react.d.ts","/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/src/components/TransactionStepper/constants.ts"],"dts":{"name":"/Users/paulclindo/local/dcspark/wrapped-smartcontracts/packages/milkomeda-wsc-ui/build/components/TransactionStepper/WrapStep.d.ts","writeByteOrderMark":false,"text":"import BigNumber from \"bignumber.js\";\r\nimport { TxPendingStatus } from \"milkomeda-wsc\";\r\nexport type WrapToken = {\r\n    assetName: string;\r\n    bridgeAllowed: boolean;\r\n    decimals: number;\r\n    fingerprint: string;\r\n    has_nft_onchain_metadata: boolean;\r\n    quantity: BigNumber;\r\n    unit: string;\r\n};\r\nexport declare const WrapStatus: {\r\n    Idle: \"Idle\";\r\n    Init: \"Init\";\r\n    Pending: \"Pending\";\r\n    Error: \"Error\";\r\n    WaitingL1Confirmation: TxPendingStatus.WaitingL1Confirmation;\r\n    WaitingBridgeConfirmation: TxPendingStatus.WaitingBridgeConfirmation;\r\n    WaitingL2Confirmation: TxPendingStatus.WaitingL2Confirmation;\r\n    Confirmed: TxPendingStatus.Confirmed;\r\n};\r\ndeclare const WrapStep: ({ nextStep }: {\r\n    nextStep: any;\r\n}) => import(\"react/jsx-runtime\").JSX.Element;\r\nexport default WrapStep;\r\nexport declare const LabelWithBalance: ({ label, amount, assetName }: {\r\n    label: any;\r\n    amount: any;\r\n    assetName: any;\r\n}) => import(\"react/jsx-runtime\").JSX.Element;\r\n"}}
